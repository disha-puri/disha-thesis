\chapter{Conslusion and Future Work}
\label{sec:research-plan}

\section{Summary}
Our dissertation is on developing a framework of certified pipelining primitives for building certified pipelining algorithms. We build a loop pipelining algorithm using this framework and certify it using ACL2 theorem prover. We have formalized the syntax and semantics of our intermediate representation (CCDFG) in ACL2. We have successfully identified and formalized a framework of succinct and provable primitives essential for loop pipelining algorithms. These primitives include $\phi$-elimination, shadow-register, interchange, branch and superstep-construction primitive. We have formalize a key invariant, unlike used before for any microprocessor pipeline verification, required for the correspondence between the sequential loop with the backedge and the pipelined loop with the backedge. We have proved that the corresponding relation is true for our algorithm and we have proved the implication chain from this relation to the correctness statement for our algorithm. Using these certified primitives as building blocks and our key invariant, we have formalized and certified a loop pipelining algorithm.
We have proved that each component of our algorithm described in Chapter~\ref{sec:pipelining-algorithm} maintains the invariant that the execution of CCDFGs before and after that component is same. Even though each component essentially decomposes into proving that our primitive is correct, we still have to prove that every application of our primitives maintains certain assumptions and does not disrupt the certification flow. Also, we have proved by induction that applying a primitive in the context of a CCDFG is correct.

%Initially, we proposed a proof sketch certifying that an unrolled sequential loop is equivalent to its unrolled pipelined counterpart. We had planned to extend the unrolled loop to include loops with backedges. However, we realized that there is no direct link between the backedges of the two CCDFGs. While the backedge in the sequential CCDFG involves scheduling steps of a particular iteration in order, the backedge of the pipelined CCDFG includes scheduling steps across different iterations. This led us to identify and formalize our key invariant required for the correspondence between the sequential loop with the backedge and the pipelined loop with the backedge. As of this writing, we have proved that the corresponding relation is true for our algorithm and we have proved the implication chain from this relation to the correctness statement for our algorithm.

Our current ACL2 script has $296$ definitions and $1012$ lemmas, including many lemmas about structural properties of CCDFGs (but not counting those from the false starts). 

Since, we have a certified loop pipelining algorithm, we can confidently say that there are no data hazards and executing a sequential loop is same as executing a pipelined loop created using our algorithm. We have tested the pipeline reference model created using our algorithm on a variety of designs across different application domains. This shows that our algorithm is practical and can be used for industrial strength designs with tens of thousands of RTL. 

With this dissertation, we have made the following major contributions:
\begin{enumerate}[--]
\item {\em Developed a framework of succinct certified primitives essential to build pipelining algorithms} : Our primitives are essential for developing certified loop pipelining algorithm in behavioral synthesis. This framework can also be extended to certify other pipelining algorithms such as function pipelines.
\item {\em Designed and certified a reference loop pipelining algorithm} : We utilize our framework of certified primitives as backbone to build our certified loop pipelining algorithm. Since a primitive can only be applied under certain conditions, when certifying the algorithm, we prove that every application of our primitive is under correct conditions and certain assumptions are maintained after the application of a primitive. We also formalize and certify a key invariant for the correspondence between the sequential and pipelined CCDFGs and propose an algorithm for handling branch conditions in pipelines.
\item {\em Evaluated our algorithm on industrial-strength designs} : We test our algorithm on a variety of designs across different application domains. If our algorithm can generate a pipeline reference model for a design, we can compare it to the pipelined RTL generated by behavioral synthesis tools using SEC. If the SEC passes, we certify the application of loop pipelining transformation is correct. We show that our algorithm can discharge industrial-strength designs.
\end{enumerate} 

\section{Next Steps}
Our dissertation shows that it is possible to develop and certify an industrial-strength loop pipelining algorithm if we can decompose it into succint certifiable primitives. We have already identified and certified these primitives. Our algorithm has components which can identify data hazards based on the given pipeline interval. Then we use our certified primitives to remove those data hazards and create a pipelined implementation.

Function pipelining algorithms also have the same type of data hazards as we have mentioned in loop pipelining algorithms. However, while loop pipelines have a fixed pipeline interval which is known at compile time, function pipelines have a variable pipeline interval for every iteration. So, instead of identifying data hazards at once for every iteration, we would have to call those functions for each iteration. After we have identified the data hazards, we can use our certified primitives to remove those data hazards. We believe that if we can modify the algorithm to identify data hazards, then we can conveniently reuse our certified primitives to certify behaviorally synthesized function pipelines as well.     